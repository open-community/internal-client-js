{"version":3,"sources":["helpers/IteratorCache.js"],"names":["IteratorCache","constructor","callback","total","size","initialData","data","offset","fetchingInProgress","fill","cacheFillInProgress","length","cacheTargetSize","list","concat","onCacheTargetReach","undefined","get","count","Error","load","splice","target","Promise","resolve","setSize"],"mappings":";;;;;;;AAAA;AACA;;AAEA;;;;AAIA,MAAMA,aAAN,CAAoB;AAChB;;;;;;;AAOAC,EAAAA,WAAW,CAAC;AACRC,IAAAA,QADQ;AAERC,IAAAA,KAFQ;AAGRC,IAAAA,IAHQ;AAIRC,IAAAA;AAJQ,GAAD,EAKR;AACC,SAAKH,QAAL,GAAgBA,QAAhB;AACA,SAAKE,IAAL,GAAYA,IAAZ;AACA,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKG,IAAL,GAAY,CAAC,GAAGD,WAAJ,CAAZ;AACA,SAAKE,MAAL,GAAc,CAAd;AACA,SAAKC,kBAAL,GAA0B,KAA1B;AACH;AAED;;;;;;;;;AAOA,QAAMC,IAAN,GAAa;AACT;AACA,QAAI,KAAKC,mBAAT,EAA8B;AAC1B;AACH;;AAED,SAAKA,mBAAL,GAA2B,IAA3B;;AAEA,WACI,EACI;AACA,SAAKJ,IAAL,CAAUK,MAAV,GAAmB,KAAKC,eAAxB,IAA2C,KAAKN,IAAL,CAAUK,MAAV,GAAmB,KAAKP,IAFvE,KAIG,KAAKG,MAAL,GAAc,KAAKJ,KAL1B,CAKgC;AALhC,MAME;AACE;AACA,YAAMU,IAAI,GAAG,MAAM,KAAKX,QAAL,CAAc,KAAKK,MAAnB,CAAnB;AACA,WAAKD,IAAL,CAAUQ,MAAV,CAAiB,GAAGD,IAApB,EAHF,CAKE;;AACA,WAAKN,MAAL,IAAeM,IAAI,CAACF,MAApB,CANF,CAQE;;AACA,UAAI,KAAKI,kBAAL,IAA2B,KAAKT,IAAL,CAAUK,MAAV,IAAoB,KAAKC,eAAxD,EAAyE;AACrE,aAAKG,kBAAL;AACA,aAAKA,kBAAL,GAA0BC,SAA1B;AACH;AACJ;;AAED,SAAKN,mBAAL,GAA2B,KAA3B;AACH;AAED;;;;;;;;;AAOA,QAAMO,GAAN,CAAUC,KAAK,GAAG,EAAlB,EAAsB;AAClB,QAAI,KAAKV,kBAAT,EAA6B;AACzB,YAAM,IAAIW,KAAJ,CAAU,gCAAV,CAAN;AACH;;AAED,SAAKX,kBAAL,GAA0B,IAA1B;AACA,UAAM,KAAKY,IAAL,CAAUF,KAAV,CAAN,CANkB,CAQlB;;AACA,UAAMZ,IAAI,GAAG,KAAKA,IAAL,CAAUe,MAAV,CAAiB,CAAjB,EAAoBH,KAApB,CAAb,CATkB,CAWlB;;AACA,SAAKT,IAAL;AAEA,SAAKD,kBAAL,GAA0B,KAA1B;AAEA,WAAOF,IAAP;AACH;AAED;;;;;;AAIA,QAAMc,IAAN,CAAWE,MAAX,EAAmB;AACf,SAAKV,eAAL,GAAuBU,MAAvB,CADe,CAGf;;AACA,SAAKb,IAAL;AAEA,UAAM,IAAIc,OAAJ,CAAaC,OAAD,IAAa;AAC3B,WAAKT,kBAAL,GAA0BS,OAA1B;AACH,KAFK,CAAN;AAIA,SAAKZ,eAAL,GAAuBI,SAAvB;AACH;AAED;;;;;;;;AAMAS,EAAAA,OAAO,CAACrB,IAAD,EAAO;AACV,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKK,IAAL;AACH;;AAjHe,C,CAoHpB;AACA;;;eACeT,a","sourcesContent":["// ============================================================\n// Class\n\n/**\n * Cache system for async iterators.\n * The class will prefetch next results in order to fill the cache.\n */\nclass IteratorCache {\n    /**\n     * @param {function(offset):Promise.<Array>} callback    - Function to call to fetch new data\n     * @param {number}                           total       - Total number of elements fetchable\n     * @param {number}                           size        - Cache size.\n     *                                                         Number of items to prefetch\n     * @param {Array}                            initialData - Initial data already fetched\n     */\n    constructor({\n        callback,\n        total,\n        size,\n        initialData,\n    }) {\n        this.callback = callback;\n        this.size = size;\n        this.total = total;\n        this.data = [...initialData];\n        this.offset = 0;\n        this.fetchingInProgress = false;\n    }\n\n    /**\n     * Perform the actual cache fill.\n     * When the cache target is reach, the onCacheTargetSize method will be executed (this is\n     * usefull when the target is lower than the cache size).\n     * This function can be executed several times.\n     * @private\n     */\n    async fill() {\n        // If a fill is already in progress, we do nothing\n        if (this.cacheFillInProgress) {\n            return;\n        }\n\n        this.cacheFillInProgress = true;\n\n        while (\n            (\n                // Cache size or target not yet reach\n                this.data.length < this.cacheTargetSize || this.data.length < this.size\n            )\n            && this.offset < this.total // There is no more data to fetch\n        ) {\n            // eslint-disable-next-line no-await-in-loop\n            const list = await this.callback(this.offset);\n            this.data.concat(...list);\n\n            // Updating the offset\n            this.offset += list.length;\n\n            // If cache target reach, we trigger the cache target function\n            if (this.onCacheTargetReach && this.data.length >= this.cacheTargetSize) {\n                this.onCacheTargetReach();\n                this.onCacheTargetReach = undefined;\n            }\n        }\n\n        this.cacheFillInProgress = false;\n    }\n\n    /**\n     * Return the nexts elements of the cache.\n     * This function CANNOT be executed in parallel: running this function two simultaneous\n     * times will throw an exception.\n     * @param {number} count - Number of elements to return\n     * @public\n     */\n    async get(count = 10) {\n        if (this.fetchingInProgress) {\n            throw new Error('IteratorCache.get called twice');\n        }\n\n        this.fetchingInProgress = true;\n        await this.load(count);\n\n        // Removing elements from the cache\n        const data = this.data.splice(0, count);\n\n        // Filling the cache\n        this.fill();\n\n        this.fetchingInProgress = false;\n\n        return data;\n    }\n\n    /**\n     * @param {Number} target - Cache target size\n     * @private\n     */\n    async load(target) {\n        this.cacheTargetSize = target;\n\n        // If no cache update in progress, force the cache fill\n        this.fill();\n\n        await new Promise((resolve) => {\n            this.onCacheTargetReach = resolve;\n        });\n\n        this.cacheTargetSize = undefined;\n    }\n\n    /**\n     * Set the size of the cache.\n     * This will force the cache to fill if necessary.\n     * @param {Number} size - New size of the cache\n     * @public\n     */\n    setSize(size) {\n        this.size = size;\n        this.fill();\n    }\n}\n\n// ============================================================\n// Exports\nexport default IteratorCache;\n"],"file":"IteratorCache.js"}